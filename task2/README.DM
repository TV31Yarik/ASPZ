# ЗАВДАННЯ ЗАГАЛЬНЕ ДЛЯ ВСІХ
## 2.1 TIME_T
### Умова 
Напишіть програму для визначення моменту, коли time_t
закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та
64-бітної архітектури. Дослідіть сегменти виконуваного файлу.  
### Пояснення 
Ця програма виводить розмір типу time_t та перевіряє, чи система вразлива до проблеми 2038 року
Якщо time_t займає 4 байти (32 біти), це означає, що часове значення закінчиться 19 січня 2038 року 
У 64-бітних системах ця проблема не виникає.<br>
### [КОД](task2.1/main.c) <br>
![Резултат 32 бітної системи ](task2.1/Знімок%20екрана%202025-04-13%20012829.png)
![Резултат 64 бітної системи ](task2.1/Screenshot%20from%202025-04-12 22-27-51.png)

## 2.2 HELLO WORLD
### Умова
Розгляньте сегменти у виконуваному файлі.
1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для
виконуваного файлу, щоб отримати його загальний розмір, і
запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int,
перекомпілюйте й повторіть вимірювання. Зверніть увагу на
відмінності.
3. Тепер додайте початкове значення в оголошення масиву
(пам’ятайте, що C не змушує вас вказувати значення для кожного
елемента масиву в ініціалізаторі). Це перемістить масив із сегмента

BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на
різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію.
Оголосіть другий великий локальний масив з ініціалізатором.
Повторіть вимірювання. Дані розташовуються всередині функцій,
залишаючись у виконуваному файлі? Яка різниця, якщо масив
ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви
компілюєте для налагодження? Для максимальної оптимізації?
Проаналізуйте результати, щоб переконатися, що:
● сегмент даних зберігається у виконуваному файлі;
● сегмент BSS не зберігається у виконуваному файлі (за винятком
примітки щодо його вимог до розміру часу виконання);
● текстовий сегмент більшою мірою піддається перевіркам
оптимізації;
● на розмір файлу a.out впливає компіляція для налагодження, але не
сегменти.

### Пояснення 
Досліджено, як зміни в коді (глобальні й локальні масиви, ініціалізація) впливають на сегменти .text, .data, .bss.
Перевірено вплив ключів компіляції -g та -O2 на розмір файлу.
### КОД ПО ПОРЯДКУ ЗАВДАНЬ 
### [main1](task2.2/main1.c)
![](task2.2/Screenshot%20from%202025-04-12%2022-49-41.png)<br>
### [main2](task2.2/main2.c)
![](task2.2/Screenshot%20from%202025-04-12%2022-51-04.png)<br>
### [main3](task2.2/main3.c)
![](task2.2/Screenshot%20from%202025-04-12%2022-52-05.png)<br>
### [main4](task2.2/main4.c)
![main4](task2.2/Screenshot%20from%202025-04-12%2022-52-47.png)<br>
![main4_DEBUG_OPT ](task2.2/Screenshot%20from%202025-04-12%2022-56-47.png)<br>

## 2.3 Stack
### Умова 
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне
розташування стека у вашій системі:
#include &lt;stdio.h&gt;
int main() {
int i;
printf(&quot;The stack top is near %p\n&quot;, &amp;i);
return 0;
}
Знайдіть розташування сегментів даних і тексту, а також купи всередині
сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і
виведіть їхні адреси.
Збільшіть розмір стека, викликавши функцію й оголосивши кілька
великих локальних масивів. Яка зараз адреса вершини стека?

Примітка: стек може розташовуватися за різними адресами на різних
архітектурах та різних ОС. Хоча ми говоримо про вершину стека, на
більшості процесорів стек зростає вниз, до пам’яті з меншими значеннями
адрес.

### Пояснення 
Програма виводить адресу змінної на вершині стека та показує, як зміна розміру стека 
(через великі локальні масиви) впливає на його адресу це демонструє, як стек зростає вниз у пам'яті
### [КОД](task2.3/main.c)<br>
![](task2.3/Screenshot%20from%202025-04-12%2023-10-57.png)

## 2.4 GDB
### Умова 
Ознайомтеся з виводом gstack і порівняйте його з GDB.
### Пояснення 
### [КОД](task2.4/main.c)<br>
![Компіляція](task2.4/Screenshot%20from%202025-04-09%2020-39-10.png)
![GDB](task2.4/Screenshot%20from%202025-04-09%2020-52-52.png)
![GDB](task2.4/Screenshot%20from%202025-04-09%2020-53-19.png)<br>
### [GDB_OUTPUT](task2.4/gdb_output.txt)<br>

gstack показує поточний стек викликів для процесу, виводячи функції та їхні аргументи. У порівнянні з GDB,
gstack надає тільки інформацію про стек викликів. GDB є більш потужним інструментом для глибокого аналізу.

## 2.5 
### Умова 
Відомо, що при виклику процедур і поверненні з них процесор
використовує стек.Чи можна в такій схемі обійтися без лічильника команд
(IP), використовуючи замість нього вершину стека? Обґрунтуйте свою
відповідь та наведіть приклади.

### Пояснення  
Ні, обійтися без лічильника команд (IP), використовуючи лише стек, неможливо
IP необхідний для вказівки на наступну інструкцію, яку має виконати процесор 
Стек використовується для зберігання адрес повернення під час виклику функцій та інших даних, але не може вказувати на наступні інструкції програми
IP забезпечує правильну послідовність виконання, в той час як стек лише зберігає стан виконання програми

# Завдання ПО ВАРІАНТАХ
## 4.Розподіл пам'яті 
### Умова 
Дослідіть техніки розподілу пам’яті в багатопотокових програмах

### Пояснення 
Спільна пам'ять:
Переваги: Ефективне використання пам'яті, швидкий обмін даними між потоками.
Недоліки: Потрібна синхронізація доступу, можливі блокування.
Використання: Коли потоки повинні ділити одні й ті ж дані.

Локальна пам'ять для кожного потоку:
Переваги: Відсутність потреби в синхронізації, кожен потік має свою копію.
Недоліки: Збільшення витрат на пам'ять.
Використання: Коли кожен потік працює з власними даними.

Атомарні операції:
Переваги: Швидкість, простота, відсутність блокувань.
Недоліки: Обмеженість операцій.
Використання: Для простих операцій з числами або вказівниками.

Пул потоків:
Переваги: Знижує витрати на створення потоків, повторне використання потоків.
Недоліки: Потрібно керувати пулом потоків.
Використання: Коли потрібно обробляти багато завдань з обмеженою кількістю потоків.

Ці техніки вибираються в залежності від вимог до продуктивності, пам'яті та складності програми.

### [Shared](task4/shared.c)<br>
### [Thread_Local](task4/threadlocal.c)<br>
### [Atomic](task4/atomic.c.c)<br>
### [Thread](task4/thread.c)<br>
