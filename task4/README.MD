# ЗАВДАННЯ ЗАГАЛЬНЕ ДЛЯ ВСІХ
## 4.1  malloc(3) за один виклик
### Умова 
Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?

### Пояснення 
Теоретично максимальний обсяг пам’яті, який можна передати у malloc(), визначається типом size_t.
На 64-бітній системі size_t займає 8 байт (64 біти), що дозволяє передати значення до 2^64
Чому на практиці обмеження – 8 ЕБ, а не 16?
Хоча тип size_t дозволяє до 16 ЕБ, сучасні 64-бітні процесори (наприклад, x86_64) фактично використовують лише 48 біт для адресації пам’яті, що обмежує доступну віртуальну пам’ять до 256 ТБ. Деякі нові процесори підтримують 57 біт (128 ПБ), але повна 64-бітна адресація не застосовується. Також системи не мають стільки фізичної пам’яті, а операційні системи вводять додаткові обмеження.
Висновок:
Теоретично malloc() може виділити до 16 ЕБ
На практиці – максимум 8 ЕБ або значно менше через архітектурні та системні обмеження

### [КОД](task4.1/main.c)<br>
![](task4.1/Screenshot%20from%202025-04-16%2017-50-47.png)
![](task4.1/Знімок%20екрана%202025-04-16%20205118.png)

## 4.2  malloc(3) від’ємний аргумент
### Умова 
Що станеться, якщо передати malloc(3) від’ємний аргумент?
Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.
### Пояснення 
Після переповнення змінної зі знаком передане значення до malloc() неявно інтерпретується як велике додатне число (через перетворення до типу size_t)
Оскільки система не має достатньо ресурсів для виділення такої великої кількості пам’яті, функція malloc() повертає NULL
### [КОД](task4.2/main.c)<br>
![](task4.2/Screenshot%20from%202025-04-16%2018-33-36.png)

## 4.3 malloc(0)
### Умова 
Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми
### Пояснення 
У цьому випадку виклик malloc(0) може повернути ненульовий вказівник, що є допустимим згідно з стандартом C. Згідно з стандартом, результатом може бути або ненульовий вказівник, або NULL. У нашому тесті malloc повернув вказівник, який можна безпечно передати в free(). Таким чином, навіть якщо кількість виділеної пам'яті дорівнює нулю, результатом може бути дійсний вказівник, що не викликає помилок при звільненні пам'яті. Це підтверджує, що malloc(0) не є помилковим викликом, і вказівник можна коректно обробляти за допомогою free().

### [КОД](task4.3/main.c)<br>
![](task4.3/Screenshot%20from%202025-04-16%2018-38-39.png)
![](task4.3/Screenshot%20from%202025-04-16%2018-38-58.png)

## 4.4 помилка у коді
### Умова 
Чи є помилки у такому коді?
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}

Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.

### Пояснення
Основна проблема в початковому коді полягає в тому, що пам'ять звільняється на кожній ітерації циклу. Це призводить до того, що в момент наступної ітерації намагаються звертатися до вже звільненої пам'яті, що може спричинити непередбачувану поведінку програми або навіть призвести до аварійного завершення.
У правильному варіанті коду пам'ять виділяється лише один раз перед початком циклу, і звільняється тільки після того, як всі операції з пам'яттю завершено. Це дозволяє коректно працювати з виділеним блоком пам'яті протягом кількох ітерацій, не порушуючи цілісність даних та не викликаючи помилок, пов'язаних із доступом до звільненої пам'яті.

### [ПРОБЛЕМНИЙ КОД](task4.4/problem_main.c)<br>
![](task4.4/Screenshot%20from%202025-04-12%2020-12-12.png)<br>

### [ВИПРАВЛЕНИЙ КОД](task4.4/main.c)<br>
![](task4.4/Screenshot%20from%202025-04-12%2020-11-15.png)

## 4.5  realloc(3) не зможе виділити пам’ять?
### Умова 
Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.

### Пояснення
Якщо realloc() не може виділити запитаний обсяг памʼяті, вона повертає NULL, але при цьому не звільняє початкову область памʼяті, на яку вказує ptr. Це означає, що в разі помилки попередній блок памʼяті не буде втрачений, і його потрібно вручну звільнити, щоб уникнути витоків. У наведеному тестовому випадку виклик realloc() із надто великим значенням імітує ситуацію помилки, а програма правильно перевіряє результат і звільняє початкову памʼять, демонструючи безпечне використання realloc().

### [КОД](task4.5/main.c)<br>
![](task4.5/Screenshot%20from%202025-04-16%2020-12-38.png)

## 4.6 realloc(3) викликати з NULL або розміром 0
### Умова 
Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок

### Пояснення
Цей приклад демонструє особливості функції realloc(). Якщо перший аргумент NULL, то realloc(NULL, 100) працює як malloc(100) і виділяє нову памʼять. Якщо викликати realloc(ptr, 0), то памʼять, на яку вказує ptr, звільняється, а realloc повертає NULL. Таким чином, функція realloc може діяти як malloc або free, залежно від аргументів.

### [КОД](task4.6/main.c)<br>
![](task4.6/Screenshot%20from%202025-04-16%2020-21-09.png)

## 4.7 reallocarray(3)
### Умова 
Перепишіть наступний код, використовуючи reallocarray(3):
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));
Порівняйте результати виконання з використанням ltrace.

### Пояснення
У програмі використовується функція calloc для виділення пам'яті для 1000 елементів типу struct sbar і функція reallocarray для зміни розміру пам'яті на 500 елементів. Якщо виділення пам'яті не вдається, програма виводить повідомлення про помилку. Після успішного виконання виводяться адреси пам'яті до та після зміни її розміру.
При використанні ltrace видно виклики функцій calloc та reallocarray, а також адреси пам'яті, що були виділені для кожного кроку

### [КОД](task4.7/main.c)<br>
![](task4.7/Screenshot%20from%202025-04-16%2020-32-17.png)

# Завдання по ВАРІАНТАХ
## 4. malloc повертає однакові адреси
### Умова 
Напишіть тестовий випадок, де malloc повертає однакові адреси після послідовного виділення та звільнення.

### Пояснення
У даному коді спочатку виділяється пам'ять для змінної ptr1 за допомогою malloc. Після цього пам'ять звільняється через free, і наступним кроком виділяється нова пам'ять для ptr2. Програма порівнює адреси ptr1 та ptr2, щоб визначити, чи повернув malloc ту саму адресу після звільнення пам'яті.
Тестовий випадок, коли malloc повертає однакові адреси після звільнення, може статися, якщо вільна пам'ять була повторно використана для нового запиту. Наприклад, якщо наступний виклик malloc запитує пам'ять того ж розміру, менеджер пам'яті може вирішити, що вже звільнене місце підходить для нового запиту. У такому випадку, якщо це місце ще не було перепризначене або використано іншими запитами, malloc може повернути ту ж саму адресу.

### [КОД](task4/main.c)<br>
![](task4/Screenshot%20from%202025-04-16%2020-42-15.png)
