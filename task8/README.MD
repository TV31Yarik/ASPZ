# ЗАВДАННЯ ЗАГАЛЬНЕ ДЛЯ ВСІХ
## 8.1  повернути в змінній count значення, відмінне від nbytes?
### Умова 
 Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

### Пояснення 
Так, виклик count = write(fd, buffer, nbytes); може повернути значення, менше за nbytes. Це відбувається, коли запис у файл або пристрій не може бути завершений повністю за один виклик, наприклад, у випадку неблокуючих (non-blocking) дескрипторів або коли буфер пристрою (наприклад, pipe) заповнений.

У наведеній програмі створюється pipe — канал зв’язку між процесами з обмеженим розміром буфера (зазвичай близько 64 КБ). Дескриптор для запису робиться неблокуючим (O_NONBLOCK). Потім намагаються записати великий масив розміром 70000 байт, який більший за типове обмеження буфера pipe. Оскільки дескриптор неблокуючий, функція write запише стільки байт, скільки зможе (зазвичай близько 65536), і поверне фактичну кількість записаних байт — меншу за nbytes. Таким чином відбувається частковий запис.
Вивід програми покаже, що запитувалося записати 70000 байт, але фактично записано менше, і виведе повідомлення про частковий запис.
Отже, часткові записи можливі, особливо у випадках неблокуючого вводу/виводу або обмежених розмірів буферів.

### [КОД](task8.1/main.c)<br>
![](task8.1/Screenshot%20from%202025-05-17%2016-27-11.png)

## 8.2  Є файл, дескриптор якого — fd
### Умова 
 Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь

### Пояснення 
Файл має байти: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. lseek(fd, 3, SEEK_SET) ставить курсор на четвертий байт, це число 2. Потім read читає 4 байти з цього місця — це будуть 2, 3, 3, 7. Тому після читання буфер буде містити саме ці числа. Програма це показує, вона записує байти у файл, ставить курсор на 3-й індекс і читає 4 байти, потім виводить їх на екран.
### [КОД](task8.2/main.c)<br>
![](task8.2/Screenshot%20from%202025-05-17%2016-30-29.png)

## 8.3  Бібліотечна функція qsort
### Умова 
 Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
 Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.


Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

### Пояснення 
Функція qsort сортує масив будь-яких типів, для чого потрібна функція порівняння, яка приймає два вказівники void* на елементи і повертає -1, 0 або 1 залежно від результату порівняння. У цій програмі створено кілька генераторів масивів: випадковий, відсортований за зростанням, відсортований у зворотному порядку і масив, де всі елементи однакові. Для кожного масиву вимірюється час роботи qsort і перевіряється, чи відсортований він після сортування. Це допомагає дослідити, які вхідні дані викликають найгіршу продуктивність qsort. Найгірший випадок для швидкого сортування — це, як правило, відсортовані або зворотно відсортовані масиви, особливо якщо реалізація qsort вибирає поганий опорний елемент. Програма автоматизує тестування і виводить результати для кожного виду вхідних даних, щоб можна було порівняти швидкодію і перевірити правильність сортування.

### [КОД](task8.3/main.c)<br>
![](task8.3/Screenshot%20from%202025-05-17%2016-33-58.png)

## 8.4 виклик fork() був успішним
### Умова 
 Виконайте наступну програму на мові програмування С:
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?


### Пояснення
Функція fork() створює новий процес — дочірній. У батьківському процесі вона повертає pid дочірнього процесу (позитивне число), у дочірньому — 0. Якщо fork() не вдалося, повертає від’ємне число.
У програмі, якщо pid < 0, виводиться повідомлення про помилку. Якщо pid == 0 — це дочірній процес, він виводить повідомлення про те, що він дочірній із pid = 0. Якщо pid > 0 — це батьківський процес, він виводить повідомлення з pid дочірнього процесу.
Оскільки два процеси працюють одночасно, їхній вивід може з’являтися у будь-якому порядку.

### [КОД](task8.4/main.c)<br>
![](task8.4/Screenshot%20from%202025-05-17%2016-35-33.png)<br>


# Завдання по ВАРІАНТАХ
## 4. read() повертає менше байтів, ніж було запрошено.
### Умова 
Проведіть експеримент і визначте, при яких умовах read() повертає менше байтів, ніж було запрошено.

### Пояснення
Функція read() може повернути менше байтів, ніж було запрошено, у таких випадках. Якщо в файлі або пристрої менше даних, ніж запитано, read повертає фактичну кількість доступних байтів. При читанні з неблокуючого пристрою (наприклад, pipe або сокету з прапорцем O_NONBLOCK) функція може повернути менше байтів, якщо наразі доступно менше даних. Також виклик read може бути перерваний сигналом, і в цьому разі може повернутися кількість прочитаних до переривання байтів. У програмі, якщо файл містить менше ніж 100 байтів, read поверне цю меншу кількість, інакше — 100, якщо інші умови не впливають.

### [КОД](task4/main.c)<br>
![](task4/Screenshot%20from%202025-05-17%2016-38-24.png)

